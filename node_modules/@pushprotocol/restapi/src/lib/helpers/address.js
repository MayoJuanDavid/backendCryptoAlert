"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pCAIP10ToWallet = exports.walletToPCAIP10 = exports.getCAIPWithChainId = exports.getCAIPAddress = exports.getFallbackETHCAIPAddress = exports.getCAIPDetails = exports.validateCAIP = exports.isValidFullCAIP10 = exports.convertToValidDID = exports.isValidPushCAIP = exports.isValidEOACAIP = exports.isValidNFTCAIP = exports.isValidSCWCAIP = void 0;
const tslib_1 = require("tslib");
const viem = require("viem");
const constants_1 = require("../constants");
const user_1 = require("../user");
/**
 * CHECK IF THE WALLET IS A VALID PUSH CAIP SCW DID
 * @param wallet scw:eip155:chainId:address
 * @returns boolean
 */
const isValidSCWCAIP = (wallet) => {
    try {
        const walletComponent = wallet.split(':');
        return (walletComponent.length === 4 &&
            walletComponent[0] === 'scw' &&
            walletComponent[1] === 'eip155' &&
            !isNaN(Number(walletComponent[2])) &&
            Number(walletComponent[2]) > 0 &&
            viem.isAddress(walletComponent[3]));
    }
    catch (err) {
        return false;
    }
};
exports.isValidSCWCAIP = isValidSCWCAIP;
/**
 * CHECK IF THE WALLET IS A VALID PUSH CAIP NFT DID
 * @param wallet nft:eip155:nftChainId:nftContractAddress:nftTokenId
 * @returns boolean
 */
const isValidNFTCAIP = (wallet) => {
    try {
        const walletComponent = wallet.split(':');
        return ((walletComponent.length === 5 || walletComponent.length === 6) &&
            walletComponent[0].toLowerCase() === 'nft' &&
            !isNaN(Number(walletComponent[4])) &&
            Number(walletComponent[4]) > 0 &&
            !isNaN(Number(walletComponent[2])) &&
            Number(walletComponent[2]) > 0 &&
            viem.isAddress(walletComponent[3]) &&
            walletComponent[1] === 'eip155');
    }
    catch (err) {
        return false;
    }
};
exports.isValidNFTCAIP = isValidNFTCAIP;
/**
 * CHECK IF THE WALLET IS A VALID PUSH CAIP EOA DID
 * @param wallet eip155:chainId:address | eip155:address
 * @returns
 */
const isValidEOACAIP = (wallet) => {
    try {
        const walletComponent = wallet.split(':');
        if (walletComponent.length === 3) {
            return (walletComponent[0] === 'eip155' &&
                !isNaN(Number(walletComponent[1])) &&
                Number(walletComponent[1]) > 0 &&
                viem.isAddress(walletComponent[2]));
        }
        if (walletComponent.length === 2) {
            return (walletComponent[0] === 'eip155' && viem.isAddress(walletComponent[1]));
        }
        return false;
    }
    catch (err) {
        return false;
    }
};
exports.isValidEOACAIP = isValidEOACAIP;
/**
 * CHECK IF THE WALLET IS A VALID PUSH CAIP
 * @param wallet
 * @returns boolean
 */
const isValidPushCAIP = (wallet) => {
    return ((0, exports.isValidEOACAIP)(wallet) ||
        (0, exports.isValidSCWCAIP)(wallet) ||
        (0, exports.isValidNFTCAIP)(wallet) ||
        viem.isAddress(wallet));
};
exports.isValidPushCAIP = isValidPushCAIP;
/**
 * CONVERT A VALID PUSH CAIP TO A VALID PUSH DID
 * @param wallet valid wallet CAIP
 * @param env optional env
 * @param chainId optional chainId
 * @param provider optional provider
 * @returns valid Push DID
 */
const convertToValidDID = (wallet, env = constants_1.ENV.STAGING, chainId, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    /** @dev Why Not throw error? - Used by Group ChatID also */
    if (!(0, exports.isValidPushCAIP)(wallet))
        return wallet;
    if ((0, exports.isValidEOACAIP)(wallet) ||
        (0, exports.isValidSCWCAIP)(wallet) ||
        ((0, exports.isValidNFTCAIP)(wallet) && wallet.split(':').length === 6))
        return wallet;
    if ((0, exports.isValidNFTCAIP)(wallet)) {
        const user = yield (0, user_1.get)({ account: wallet, env: env });
        if (user && user.did)
            return user.did;
        const epoch = Math.floor(Date.now() / 1000);
        return `${wallet}:${epoch}`;
    }
    // TODO: Implement SCW DID CHECK
    if (provider) {
        try {
            // check if onChain code exists
        }
        catch (err) {
            // Ignore if it fails
        }
    }
    return chainId ? `eip155:${chainId}:${wallet}` : `eip155:${wallet}`;
});
exports.convertToValidDID = convertToValidDID;
/**
 * CHECK IF THE WALLET IS A VALID FULL CAIP10
 * @param wallet eip155:chainId:address
 * @returns boolean
 */
const isValidFullCAIP10 = (wallet) => {
    const walletComponent = wallet.split(':');
    if (isNaN(Number(walletComponent[1])))
        return false;
    return (walletComponent[0] === 'eip155' &&
        !isNaN(Number(walletComponent[1])) &&
        Number(walletComponent[1]) > 0 &&
        viem.isAddress(walletComponent[2]));
};
exports.isValidFullCAIP10 = isValidFullCAIP10;
const AddressValidators = {
    // Ethereum
    eip155: ({ address }) => {
        return (0, exports.isValidPushCAIP)(address);
    },
    // Add other chains here
};
function validateCAIP(addressInCAIP) {
    const [blockchain, networkId, address] = addressInCAIP.split(':');
    if (!blockchain)
        return false;
    if (!networkId)
        return false;
    if (!address)
        return false;
    if ((0, exports.isValidNFTCAIP)(addressInCAIP))
        return true;
    const validatorFn = AddressValidators[blockchain];
    return validatorFn({ address });
}
exports.validateCAIP = validateCAIP;
function getCAIPDetails(addressInCAIP) {
    if (validateCAIP(addressInCAIP)) {
        const [blockchain, networkId, address] = addressInCAIP.split(':');
        return {
            blockchain,
            networkId,
            address,
        };
    }
    return null;
}
exports.getCAIPDetails = getCAIPDetails;
function getFallbackETHCAIPAddress(env, address) {
    let chainId = 1; // by default PROD
    if (env === constants_1.default.ENV.DEV ||
        env === constants_1.default.ENV.STAGING ||
        env === constants_1.default.ENV.LOCAL) {
        chainId = 11155111;
    }
    return `eip155:${chainId}:${address}`;
}
exports.getFallbackETHCAIPAddress = getFallbackETHCAIPAddress;
/**
 * This helper
 *  checks if a VALID CAIP
 *    return the CAIP
 *  else
 *    check if valid ETH
 *      return a CAIP representation of that address (EIP155 + env)
 *    else
 *      throw error!
 */
function getCAIPAddress(env, address, msg) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, exports.isValidNFTCAIP)(address)) {
            return yield (0, exports.convertToValidDID)(address, env);
        }
        if (validateCAIP(address)) {
            return address;
        }
        else {
            if ((0, exports.isValidPushCAIP)(address)) {
                return getFallbackETHCAIPAddress(env, address);
            }
            else {
                throw Error(`Invalid Address! ${msg} \n Address: ${address}`);
            }
        }
    });
}
exports.getCAIPAddress = getCAIPAddress;
const getCAIPWithChainId = (address, chainId, msg) => {
    if ((0, exports.isValidPushCAIP)(address)) {
        if (!address.includes('eip155:'))
            return `eip155:${chainId}:${address}`;
        else
            return address;
    }
    else {
        throw Error(`Invalid Address! ${msg} \n Address: ${address}`);
    }
};
exports.getCAIPWithChainId = getCAIPWithChainId;
// P = Partial CAIP
const walletToPCAIP10 = (account) => {
    if ((0, exports.isValidNFTCAIP)(account) || account.includes('eip155:')) {
        return account;
    }
    return 'eip155:' + account;
};
exports.walletToPCAIP10 = walletToPCAIP10;
const pCAIP10ToWallet = (wallet) => {
    if ((0, exports.isValidNFTCAIP)(wallet))
        return wallet;
    wallet = wallet.replace('eip155:', '');
    return wallet;
};
exports.pCAIP10ToWallet = pCAIP10ToWallet;
//# sourceMappingURL=address.js.map