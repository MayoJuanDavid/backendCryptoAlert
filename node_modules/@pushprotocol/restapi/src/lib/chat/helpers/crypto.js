"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptAndVerifyMessage = exports.getDecryptedPrivateKey = exports.getEip712Signature = exports.getEip191Signature = exports.getEncryptedRequestCore = exports.getEncryptedRequest = exports.decryptFeeds = exports.signMessageWithPGPCore = exports.signMessageWithPGP = exports.encryptAndSignCore = exports.encryptAndSign = void 0;
const tslib_1 = require("tslib");
const PGP = require("./pgp");
const AES = require("./aes");
const CryptoJS = require("crypto-js");
const user_1 = require("../../user");
const helpers_1 = require("../../helpers");
const user_2 = require("../../user");
const service_1 = require("./service");
const constants_1 = require("../../constants");
const signature_1 = require("./signature");
const aes_1 = require("./aes");
const getEncryptedSecret_1 = require("./getEncryptedSecret");
const getGroup_1 = require("../getGroup");
const cache_1 = require("../../helpers/cache");
const ipfs_1 = require("../ipfs");
const SIG_TYPE_V2 = 'eip712v2';
const encryptAndSign = ({ plainText, keys, privateKeyArmored, secretKey, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.encryptAndSignCore)({
        plainText,
        keys,
        privateKeyArmored,
        secretKey,
        pgpHelper: PGP.PGPHelper,
    });
});
exports.encryptAndSign = encryptAndSign;
const encryptAndSignCore = ({ plainText, keys, privateKeyArmored, secretKey, pgpHelper, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const cipherText = AES.aesEncrypt({ plainText, secretKey });
    const encryptedSecret = yield pgpHelper.pgpEncrypt({
        plainText: secretKey,
        keys: keys,
    });
    const signature = yield pgpHelper.sign({
        message: cipherText,
        signingKey: privateKeyArmored,
    });
    return {
        cipherText,
        encryptedSecret,
        signature,
        sigType: 'pgp',
        encType: 'pgp',
    };
});
exports.encryptAndSignCore = encryptAndSignCore;
const signMessageWithPGP = ({ message, privateKeyArmored, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.signMessageWithPGPCore)({
        message,
        privateKeyArmored,
        pgpHelper: PGP.PGPHelper,
    });
});
exports.signMessageWithPGP = signMessageWithPGP;
const signMessageWithPGPCore = ({ message, privateKeyArmored, pgpHelper, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const signature = yield pgpHelper.sign({
        message: message,
        signingKey: privateKeyArmored,
    });
    return {
        signature,
        sigType: 'pgp',
    };
});
exports.signMessageWithPGPCore = signMessageWithPGPCore;
const decryptFeeds = ({ feeds, connectedUser, pgpPrivateKey, env = constants_1.default.ENV.PROD, pgpHelper, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const validateAndDecryptFeed = (feed) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (!pgpPrivateKey) {
            throw new Error('Decrypted private key is necessary');
        }
        if (feed.msg.encType !== 'PlainText') {
            const senderCAIP10 = feed.msg.fromCAIP10;
            const isSenderConnectedUser = senderCAIP10 === connectedUser.wallets.split(',')[0];
            let publicKey;
            if (!isSenderConnectedUser) {
                /**
                 * CACHE
                 */
                const cacheKey = `pgpPubKey-${senderCAIP10}`;
                // Check if the pubkey is already in the cache
                if (cache_1.cache.has(cacheKey)) {
                    publicKey = cache_1.cache.get(cacheKey);
                }
                else {
                    // If not in cache, fetch from API
                    const otherPeer = yield (0, user_2.get)({ account: senderCAIP10, env });
                    // Cache the pubkey data
                    cache_1.cache.set(cacheKey, otherPeer.publicKey);
                    publicKey = otherPeer.publicKey;
                }
            }
            else {
                publicKey = connectedUser.publicKey;
            }
            feed.msg = yield (0, exports.decryptAndVerifyMessage)(feed.msg, publicKey, pgpPrivateKey, env, pgpHelper);
        }
    });
    for (const feed of feeds) {
        yield validateAndDecryptFeed(feed);
    }
    return feeds;
});
exports.decryptFeeds = decryptFeeds;
const getEncryptedRequest = (receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.getEncryptedRequestCore)(receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey, PGP.PGPHelper);
});
exports.getEncryptedRequest = getEncryptedRequest;
const getEncryptedRequestCore = (receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!isGroup) {
        const receiverCreatedUser = yield (0, user_1.get)({
            account: receiverAddress,
            env,
        });
        if (!(receiverCreatedUser === null || receiverCreatedUser === void 0 ? void 0 : receiverCreatedUser.publicKey)) {
            if (!(0, helpers_1.isValidPushCAIP)(receiverAddress)) {
                throw new Error(`Invalid receiver address!`);
            }
            yield (0, service_1.createUserService)({
                user: receiverAddress,
                publicKey: '',
                encryptedPrivateKey: '',
                env,
            });
            // If the user is being created here, that means that user don't have a PGP keys. So this intent will be in plaintext
            const { signature } = yield (0, exports.signMessageWithPGPCore)({
                message: message,
                privateKeyArmored: senderCreatedUser.privateKey,
                pgpHelper: pgpHelper,
            });
            return {
                message: message,
                encryptionType: 'PlainText',
                aesEncryptedSecret: '',
                signature: signature,
            };
        }
        else {
            // It's possible for a user to be created but the PGP keys still not created
            if (!receiverCreatedUser.publicKey.includes('-----BEGIN PGP PUBLIC KEY BLOCK-----')) {
                const { signature } = yield (0, exports.signMessageWithPGPCore)({
                    message: message,
                    privateKeyArmored: senderCreatedUser.privateKey,
                    pgpHelper: pgpHelper,
                });
                return {
                    message: message,
                    encryptionType: 'PlainText',
                    aesEncryptedSecret: '',
                    signature: signature,
                };
            }
            else {
                const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSignCore)({
                    plainText: message,
                    keys: [receiverCreatedUser.publicKey, senderCreatedUser.publicKey],
                    privateKeyArmored: senderCreatedUser.privateKey,
                    secretKey,
                    pgpHelper: pgpHelper,
                });
                return {
                    message: cipherText,
                    encryptionType: 'pgp',
                    aesEncryptedSecret: encryptedSecret,
                    signature: signature,
                };
            }
        }
    }
    else if (group) {
        if (group.isPublic) {
            const { signature } = yield (0, exports.signMessageWithPGPCore)({
                message: message,
                privateKeyArmored: senderCreatedUser.privateKey,
                pgpHelper: pgpHelper,
            });
            return {
                message: message,
                encryptionType: 'PlainText',
                aesEncryptedSecret: '',
                signature: signature,
            };
        }
        else {
            // Private Groups
            // 1. Private Groups with session keys
            if (group.sessionKey && group.encryptedSecret) {
                const cipherText = AES.aesEncrypt({
                    plainText: message,
                    secretKey,
                });
                const signature = yield pgpHelper.sign({
                    message: cipherText,
                    signingKey: senderCreatedUser.privateKey,
                });
                return {
                    message: cipherText,
                    encryptionType: 'pgpv1:group',
                    aesEncryptedSecret: null,
                    signature: signature,
                };
            }
            else {
                // do a getGroupCall to get keys of all members
                const groupWithMembers = yield (0, getGroup_1.getGroup)({
                    chatId: group.chatId,
                    env: env,
                });
                const publicKeys = groupWithMembers.members.map((member) => member.publicKey);
                const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSignCore)({
                    plainText: message,
                    keys: publicKeys,
                    privateKeyArmored: senderCreatedUser.privateKey,
                    secretKey,
                    pgpHelper: pgpHelper,
                });
                return {
                    message: cipherText,
                    encryptionType: 'pgp',
                    aesEncryptedSecret: encryptedSecret,
                    signature: signature,
                };
            }
        }
    }
    else {
        throw new Error('Unable to find Group Data');
    }
});
exports.getEncryptedRequestCore = getEncryptedRequestCore;
const getEip191Signature = (wallet, message, version = 'v1') => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn('This method is deprecated. Provide signer in the function');
        // sending random signature for making it backward compatible
        return { signature: 'xyz', sigType: 'a' };
    }
    const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
    // EIP191 signature
    const pushSigner = new helpers_1.Signer(_signer);
    const signature = yield pushSigner.signMessage(message);
    const sigType = version === 'v1' ? 'eip191' : 'eip191v2';
    return { verificationProof: `${sigType}:${signature}` };
});
exports.getEip191Signature = getEip191Signature;
const getEip712Signature = (wallet, hash, isDomainEmpty) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn('This method is deprecated. Provide signer in the function');
        // sending random signature for making it backward compatible
        return { signature: 'xyz', sigType: 'a' };
    }
    const typeInformation = (0, signature_1.getTypeInformation)();
    const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
    const pushSigner = new helpers_1.Signer(_signer);
    let chainId;
    try {
        chainId = yield pushSigner.getChainId();
    }
    catch (err) {
        chainId = 1;
    }
    const domain = (0, signature_1.getDomainInformation)(chainId);
    // sign a message using EIP712
    const signedMessage = yield pushSigner.signTypedData(isDomainEmpty ? {} : domain, typeInformation, { data: hash }, 'Data');
    const verificationProof = isDomainEmpty
        ? `${SIG_TYPE_V2}:${signedMessage}`
        : `${SIG_TYPE_V2}:${chainId}:${signedMessage}`;
    return { verificationProof };
});
exports.getEip712Signature = getEip712Signature;
function getDecryptedPrivateKey(wallet, user, address, env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let decryptedPrivateKey;
        if (wallet.signer) {
            decryptedPrivateKey = yield (0, helpers_1.decryptPGPKey)({
                signer: wallet.signer,
                encryptedPGPPrivateKey: user.encryptedPrivateKey,
                env,
            });
        }
        else {
            decryptedPrivateKey = yield (0, helpers_1.decryptWithWalletRPCMethod)(user.encryptedPrivateKey, address);
        }
        return decryptedPrivateKey;
    });
}
exports.getDecryptedPrivateKey = getDecryptedPrivateKey;
/**
 * Decrypts and verifies a Push Chat Message
 * @param message encrypted chat message
 * @param pgpPublicKey pgp public key of signer of message - used for verification
 * @param pgpPrivateKey pgp private key of receiver - used for decryption
 */
const decryptAndVerifyMessage = (message, pgpPublicKey, pgpPrivateKey, env, pgpHelper = PGP.PGPHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    /**
     * VERIFICATION
     * If verification proof is present then check that else check messageContent Signature
     */
    if (message.verificationProof &&
        message.verificationProof.split(':')[0] === 'pgpv2') {
        const bodyToBeHashed = {
            fromDID: message.fromDID,
            toDID: message.fromDID,
            fromCAIP10: message.fromCAIP10,
            toCAIP10: message.toCAIP10,
            messageObj: message.messageObj,
            messageType: message.messageType,
            encType: message.encType,
            encryptedSecret: message.encryptedSecret,
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = message.verificationProof.split(':')[1];
        yield pgpHelper.verifySignature({
            messageContent: hash,
            signatureArmored: signature,
            publicKeyArmored: pgpPublicKey,
        });
    }
    else if (message.verificationProof &&
        message.verificationProof.split(':')[0] === 'pgpv3') {
        const bodyToBeHashed = {
            fromDID: message.fromDID,
            toDID: message.fromDID,
            fromCAIP10: message.fromCAIP10,
            toCAIP10: message.toCAIP10,
            messageObj: message.messageObj,
            messageType: message.messageType,
            encType: message.encType,
            sessionKey: message.sessionKey,
            encryptedSecret: message.encryptedSecret,
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = message.verificationProof.split(':')[1];
        yield pgpHelper.verifySignature({
            messageContent: hash,
            signatureArmored: signature,
            publicKeyArmored: pgpPublicKey,
        });
    }
    else {
        if (message.link == null) {
            const bodyToBeHashed = {
                fromDID: message.fromDID,
                toDID: message.toDID,
                messageContent: message.messageContent,
                messageType: message.messageType,
            };
            const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
            try {
                yield pgpHelper.verifySignature({
                    messageContent: hash,
                    signatureArmored: message.signature,
                    publicKeyArmored: pgpPublicKey,
                });
            }
            catch (err) {
                yield pgpHelper.verifySignature({
                    messageContent: message.messageContent,
                    signatureArmored: message.signature,
                    publicKeyArmored: pgpPublicKey,
                });
            }
        }
        else {
            yield pgpHelper.verifySignature({
                messageContent: message.messageContent,
                signatureArmored: message.signature,
                publicKeyArmored: pgpPublicKey,
            });
        }
    }
    /**
     * DECRYPTION
     * 1. Fetch encryptedSecret for given sessionKey ( if encType is pgpv1:group - v2 private group )
     * 1. Decrypt encryptedSecret using pgpPrivateKey
     * 2. Decrypt messageObj & messageContent using decryptedSecret
     */
    const decryptedMessage = Object.assign({}, message);
    try {
        let decryptedSecret;
        if (message.encType === 'pgpv1:group') {
            /**
             * CACHE [ sessionKey -> decryptedSecret ]
             */
            const cacheKey = `sessionKey-${message.sessionKey}`;
            if (cache_1.cache.has(cacheKey)) {
                decryptedSecret = cache_1.cache.get(cacheKey);
            }
            else {
                /**
                 * Get encryptedSecret from Backend using sessionKey for this encryption type
                 */
                const encryptedSecret = yield (0, getEncryptedSecret_1.getEncryptedSecret)({
                    sessionKey: message.sessionKey,
                    env,
                });
                decryptedSecret = yield pgpHelper.pgpDecrypt({
                    cipherText: encryptedSecret,
                    toPrivateKeyArmored: pgpPrivateKey,
                });
                cache_1.cache.set(cacheKey, decryptedSecret);
            }
        }
        else {
            decryptedSecret = yield pgpHelper.pgpDecrypt({
                cipherText: message.encryptedSecret,
                toPrivateKeyArmored: pgpPrivateKey,
            });
        }
        decryptedMessage.messageContent = (0, aes_1.aesDecrypt)({
            cipherText: message.messageContent,
            secretKey: decryptedSecret,
        });
        if (message.messageObj) {
            const decryptedMessageObj = (0, aes_1.aesDecrypt)({
                cipherText: message.messageObj,
                secretKey: decryptedSecret,
            });
            /**
             * @dev - messageObj can be an invalid JSON string which needs to be handled
             * @dev - swift sdk sends messageObj as invalid json string
             */
            try {
                decryptedMessage.messageObj = JSON.parse(decryptedMessageObj);
            }
            catch (err) {
                decryptedMessage.messageObj = decryptedMessageObj;
            }
            try {
                if (decryptedMessage.messageObj.reference) {
                    const reference = decryptedMessage.messageObj.reference;
                    if (reference && reference.split(':').length === 1) {
                        const message = yield (0, ipfs_1.getCID)(reference, { env });
                        decryptedMessage.messageObj.reference = message.cid;
                    }
                }
            }
            catch (err) {
                // Ignore Dangling Reference
            }
        }
    }
    catch (err) {
        decryptedMessage.messageContent = decryptedMessage.messageObj =
            'Unable to Decrypt Message';
    }
    return decryptedMessage;
});
exports.decryptAndVerifyMessage = decryptAndVerifyMessage;
//# sourceMappingURL=crypto.js.map