"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGroupCoreV2 = exports.createGroupV2 = void 0;
const tslib_1 = require("tslib");
const helpers_1 = require("../helpers");
const constants_1 = require("../constants");
const helpers_2 = require("./helpers");
const CryptoJS = require("crypto-js");
const validationError_1 = require("../errors/validationError");
const axiosUtil_1 = require("../utils/axiosUtil");
const createGroupV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.createGroupCoreV2)(options, helpers_2.PGPHelper);
});
exports.createGroupV2 = createGroupV2;
const createGroupCoreV2 = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { account = null, signer = null, pgpPrivateKey = null, env = constants_1.default.ENV.PROD, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins, } = options;
    try {
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        const convertedMembersPromise = members.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedAdminsPromise = admins.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedMembers = yield Promise.all(convertedMembersPromise);
        const convertedAdmins = yield Promise.all(convertedAdminsPromise);
        /**
         * VALIDATIONS
         */
        createGroupV2OptionsValidator(options);
        /**
         * PROFILE VERIFICATION PROOF
         */
        const profileVerificationBody = {
            groupName,
            groupDescription,
            groupImage,
            rules,
            isPublic,
            groupType,
        };
        const profileHash = CryptoJS.SHA256(JSON.stringify(profileVerificationBody)).toString();
        const profileSignature = yield pgpHelper.sign({
            message: profileHash,
            signingKey: connectedUser.privateKey,
        });
        const profileVerificationProof = `pgpv2:${profileSignature}:${connectedUser.did}`;
        /**
         * CONFIG VERIFICATION PROOF
         */
        const configVerificationBody = {
            meta,
            scheduleAt,
            scheduleEnd,
            status,
        };
        const configHash = CryptoJS.SHA256(JSON.stringify(configVerificationBody)).toString();
        const configSignature = yield pgpHelper.sign({
            message: configHash,
            signingKey: connectedUser.privateKey,
        });
        const configVerificationProof = `pgpv2:${configSignature}:${connectedUser.did}`;
        /**
         * IDEMPOTENT VERIFICATION PROOF
         */
        const idempotentVerificationBody = {
            members: convertedMembers,
            admins: convertedAdmins,
        };
        const idempotentHash = CryptoJS.SHA256(JSON.stringify(idempotentVerificationBody)).toString();
        const idempotentSignature = yield pgpHelper.sign({
            message: idempotentHash,
            signingKey: connectedUser.privateKey,
        });
        const idempotentVerificationProof = `pgpv2:${idempotentSignature}:${connectedUser.did}`;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v2/chat/groups`;
        const body = {
            groupName,
            groupDescription,
            groupImage,
            rules,
            isPublic,
            groupType,
            profileVerificationProof,
            config: {
                meta,
                scheduleAt,
                scheduleEnd,
                status,
                configVerificationProof,
            },
            members: convertedMembers,
            admins: convertedAdmins,
            idempotentVerificationProof,
        };
        const response = yield (0, axiosUtil_1.axiosPost)(apiEndpoint, body);
        return response.data;
    }
    catch (error) {
        throw (0, validationError_1.handleError)(error, exports.createGroupV2.name);
    }
});
exports.createGroupCoreV2 = createGroupCoreV2;
const createGroupV2OptionsValidator = (options) => {
    const { account = null, signer = null, pgpPrivateKey = null, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins, } = options;
    if (!pgpPrivateKey && !signer) {
        throw new Error(`At least one from pgpPrivateKey or signer is necessary!`);
    }
    if (groupName == null || groupName.length == 0) {
        throw new Error(`groupName cannot be null or empty`);
    }
    if (groupName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
    }
    if (groupDescription && groupDescription.length > 150) {
        throw new Error(`groupDescription cannot be more than 150 characters`);
    }
    for (let i = 0; i < members.length; i++) {
        if (members[i] && !(0, helpers_1.isValidPushCAIP)(members[i])) {
            throw new Error(`Invalid member address!`);
        }
    }
    for (let i = 0; i < admins.length; i++) {
        if (!(0, helpers_1.isValidPushCAIP)(admins[i])) {
            throw new Error(`Invalid admin address!`);
        }
    }
    (0, helpers_2.validateScheduleDates)(scheduleAt, scheduleEnd);
};
//# sourceMappingURL=createGroupV2.js.map