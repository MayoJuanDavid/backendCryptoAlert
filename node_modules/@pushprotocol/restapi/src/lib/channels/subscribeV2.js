"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeV2 = void 0;
const tslib_1 = require("tslib");
const helpers_1 = require("../helpers");
const signature_helpers_1 = require("./signature.helpers");
const constants_1 = require("../constants");
const axiosUtil_1 = require("../utils/axiosUtil");
const helpers_2 = require("../chat/helpers");
const CryptoJS = require("crypto-js");
const subscribeV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const { signer, channelAddress, userAddress, settings = undefined, verifyingContractAddress, env = constants_1.default.ENV.PROD, origin, onSuccess, onError, pgpPrivateKey, } = options || {};
    try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, 'Channel');
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
            throw Error('Invalid Channel CAIP!');
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, 'User');
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
            throw Error('Invalid User CAIP!');
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/subscribe`;
        let verificationProof;
        let messageInformation = { data: {} };
        if (pgpPrivateKey) {
            const data = (0, signature_helpers_1.getSubscriptionMessageV2)(channelCAIPDetails.address, _userAddress, 'Subscribe', settings);
            messageInformation = {
                data: data,
            };
            const hash = CryptoJS.SHA256(JSON.stringify(messageInformation)).toString();
            console.log(' hash ', hash);
            const signature = yield (0, helpers_2.sign)({
                message: hash,
                signingKey: pgpPrivateKey,
            });
            verificationProof = `pgpv4:${signature}`;
        }
        else {
            const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
            // get type information
            const typeInformation = (0, signature_helpers_1.getTypeInformationV2)();
            messageInformation = {
                data: (0, signature_helpers_1.getSubscriptionMessageV2)(channelCAIPDetails.address, userCAIPDetails.address, 'Subscribe', settings),
            };
            // Existing EIP712 flow
            const pushSigner = new helpers_1.Signer(signer);
            const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, 'Data');
            verificationProof = `eip712v2:${signature}`;
        }
        const body = {
            verificationProof: verificationProof,
            message: messageInformation.data,
            origin: origin,
        };
        const res = yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === 'function')
            onSuccess();
        return { status: res.status, message: 'successfully opted into channel' };
    }
    catch (err) {
        if (typeof onError === 'function')
            onError(err);
        return {
            status: (_b = (_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : '',
            message: err instanceof Error ? err.message : JSON.stringify(err),
        };
    }
});
exports.subscribeV2 = subscribeV2;
//# sourceMappingURL=subscribeV2.js.map