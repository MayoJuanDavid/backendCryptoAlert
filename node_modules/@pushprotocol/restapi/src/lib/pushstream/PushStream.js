"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushStream = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const socketClient_1 = require("./socketClient");
const constants_1 = require("../constants");
const pushStreamTypes_1 = require("./pushStreamTypes");
const DataModifier_1 = require("./DataModifier");
const helpers_1 = require("../helpers");
const chat_1 = require("../pushapi/chat");
const config_1 = require("../config");
const payloads_1 = require("../payloads");
const uuid_1 = require("uuid");
class PushStream extends events_1.EventEmitter {
    constructor(account, _listen, options, decryptedPgpPvtKey, progressHook, signer) {
        var _a;
        super();
        this._listen = _listen;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.progressHook = progressHook;
        this.signer = signer;
        this.account = account;
        this.raw = (_a = options.raw) !== null && _a !== void 0 ? _a : false;
        this.options = options;
        this.listen = _listen;
        this.disconnected = false;
        this.uid = (0, uuid_1.v4)();
        this.chatSocketCount = 0;
        this.notifSocketCount = 0;
        this.chatSocketConnected = false;
        this.notifSocketConnected = false;
        this.chatInstance = new chat_1.Chat(this.account, this.options.env, config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD], this.decryptedPgpPvtKey, this.signer, this.progressHook);
    }
    static initialize(account, listen, env, decryptedPgpPvtKey, progressHook, signer, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const defaultOptions = {
                raw: false,
                connection: {
                    auto: true,
                    retries: 3,
                },
                env: env,
            };
            if (!listen || listen.length === 0) {
                throw new Error('The listen property must have at least one STREAM type.');
            }
            const settings = Object.assign(Object.assign({}, defaultOptions), options);
            const accountToUse = settings.overrideAccount || account;
            if (listen.includes('*')) {
                listen = Object.values(pushStreamTypes_1.STREAM);
            }
            const stream = new PushStream(accountToUse, listen, settings, decryptedPgpPvtKey, progressHook, signer);
            return stream;
        });
    }
    reinit(listen, newOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.listen = listen;
            this.options = Object.assign(Object.assign({}, this.options), newOptions);
            yield this.connect(true);
        });
    }
    connect(reinit = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                    const shouldInitializeChatSocket = !this.listen ||
                        this.listen.length === 0 ||
                        this.listen.includes(pushStreamTypes_1.STREAM.CHAT) ||
                        this.listen.includes(pushStreamTypes_1.STREAM.CHAT_OPS) ||
                        this.listen.includes(pushStreamTypes_1.STREAM.SPACE) ||
                        this.listen.includes(pushStreamTypes_1.STREAM.SPACE_OPS);
                    const shouldInitializeNotifSocket = !this.listen ||
                        this.listen.length === 0 ||
                        this.listen.includes(pushStreamTypes_1.STREAM.NOTIF) ||
                        this.listen.includes(pushStreamTypes_1.STREAM.NOTIF_OPS) ||
                        this.listen.includes(pushStreamTypes_1.STREAM.VIDEO);
                    console.log('RestAPI::PushStream::connect - Initialization flags:', {
                        shouldInitializeChatSocket,
                        shouldInitializeNotifSocket,
                    });
                    let isChatSocketConnected = reinit ? this.chatSocketConnected : false;
                    let isNotifSocketConnected = reinit ? this.notifSocketConnected : false;
                    // Function to check and emit the STREAM.CONNECT event
                    const checkAndEmitConnectEvent = () => {
                        console.log('RestAPI::PushStream::connect - Checking conditions for STREAM.CONNECT event.', {
                            shouldInitializeChatSocket,
                            isChatSocketConnected,
                            shouldInitializeNotifSocket,
                            isNotifSocketConnected,
                        });
                        if (((shouldInitializeChatSocket && isChatSocketConnected) ||
                            !shouldInitializeChatSocket) &&
                            ((shouldInitializeNotifSocket && isNotifSocketConnected) ||
                                !shouldInitializeNotifSocket)) {
                            this.emit(pushStreamTypes_1.STREAM.CONNECT);
                            console.log('RestAPI::PushStream::connect - Emitted STREAM.CONNECT');
                            resolve();
                        }
                        else {
                            console.log('RestAPI::PushStream:: not emitting');
                        }
                    };
                    const TIMEOUT_DURATION = 5000; // Timeout duration in milliseconds
                    setTimeout(() => {
                        if (!(this.notifSocketConnected || this.chatSocketConnected)) {
                            reject(new Error('Connection timeout')); // Reject the promise if connect event is not emitted within the timeout
                        }
                    }, TIMEOUT_DURATION);
                    const handleSocketDisconnection = (socketType) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        if (socketType === 'chat') {
                            isChatSocketConnected = false;
                            this.chatSocketConnected = false;
                            console.log('RestAPI::PushStream::handleSocketDisconnection - Chat socket disconnected. Decrementing chatSocketCount.', 'Previous chatSocketCount:', this.chatSocketCount);
                            this.chatSocketCount--;
                            console.log('RestAPI::PushStream::handleSocketDisconnection - New chatSocketCount:', this.chatSocketCount);
                            if (isNotifSocketConnected) {
                                if (this.pushNotificationSocket &&
                                    this.pushNotificationSocket.connected) {
                                    console.log('RestAPI::PushStream::handleSocketDisconnection - Disconnecting Notification Socket...');
                                    this.pushNotificationSocket.disconnect();
                                }
                            }
                            else {
                                this.emit(pushStreamTypes_1.STREAM.DISCONNECT);
                                console.log('RestAPI::PushStream::handleSocketDisconnection - Emitted STREAM.DISCONNECT for chat.');
                            }
                        }
                        else if (socketType === 'notif') {
                            isNotifSocketConnected = false;
                            this.notifSocketConnected = false;
                            console.log('RestAPI::PushStream::handleSocketDisconnection - Notification socket disconnected. Decrementing notifSocketCount.', 'Previous notifSocketCount:', this.notifSocketCount);
                            this.notifSocketCount--;
                            console.log('RestAPI::PushStream::handleSocketDisconnection - New notifSocketCount:', this.notifSocketCount);
                            if (isChatSocketConnected) {
                                if (this.pushChatSocket && this.pushChatSocket.connected) {
                                    console.log('RestAPI::PushStream::handleSocketDisconnection - Disconnecting Chat Socket...');
                                    this.pushChatSocket.disconnect();
                                }
                            }
                            else {
                                this.emit(pushStreamTypes_1.STREAM.DISCONNECT);
                                console.log('RestAPI::PushStream::handleSocketDisconnection - Emitted STREAM.DISCONNECT for notification.');
                            }
                        }
                    });
                    if (shouldInitializeChatSocket) {
                        if (!this.pushChatSocket) {
                            // If pushChatSocket does not exist, create a new socket connection
                            console.log('RestAPI::PushStream::ChatSocket::Create - pushChatSocket does not exist, creating new socket connection...');
                            this.pushChatSocket = yield (0, socketClient_1.createSocketConnection)({
                                user: (0, helpers_1.walletToPCAIP10)(this.account),
                                socketType: 'chat',
                                socketOptions: {
                                    autoConnect: (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.auto) !== null && _c !== void 0 ? _c : true,
                                    reconnectionAttempts: (_f = (_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.connection) === null || _e === void 0 ? void 0 : _e.retries) !== null && _f !== void 0 ? _f : 3,
                                },
                                env: (_g = this.options) === null || _g === void 0 ? void 0 : _g.env,
                            });
                            if (!this.pushChatSocket) {
                                reject(new Error('RestAPI::PushStream::ChatSocket::Error - Push chat socket not connected'));
                            }
                        }
                        else if (this.pushChatSocket && !this.chatSocketConnected) {
                            // If pushChatSocket exists but is not connected, attempt to reconnect
                            console.log('RestAPI::PushStream::ChatSocket::Reconnect - Attempting to reconnect push chat socket...');
                            this.pushChatSocket.connect(); // Assuming connect() is the method to re-establish connection
                        }
                        else {
                            console.log('RestAPI::PushStream::ChatSocket::Status - Push chat socket already connected');
                        }
                    }
                    if (shouldInitializeNotifSocket) {
                        if (!this.pushNotificationSocket) {
                            // If pushNotificationSocket does not exist, create a new socket connection
                            console.log('RestAPI::PushStream::NotifSocket::Create - pushNotificationSocket does not exist, creating new socket connection...');
                            this.pushNotificationSocket = yield (0, socketClient_1.createSocketConnection)({
                                user: (0, helpers_1.pCAIP10ToWallet)(this.account),
                                env: (_h = this.options) === null || _h === void 0 ? void 0 : _h.env,
                                socketOptions: {
                                    autoConnect: (_l = (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.connection) === null || _k === void 0 ? void 0 : _k.auto) !== null && _l !== void 0 ? _l : true,
                                    reconnectionAttempts: (_p = (_o = (_m = this.options) === null || _m === void 0 ? void 0 : _m.connection) === null || _o === void 0 ? void 0 : _o.retries) !== null && _p !== void 0 ? _p : 3,
                                },
                            });
                            if (!this.pushNotificationSocket) {
                                reject(new Error('RestAPI::PushStream::NotifSocket::Error - Push notification socket not connected'));
                            }
                        }
                        else if (this.pushNotificationSocket &&
                            !this.notifSocketConnected) {
                            // If pushNotificationSocket exists but is not connected, attempt to reconnect
                            console.log('RestAPI::PushStream::NotifSocket::Reconnect - Attempting to reconnect push notification socket...');
                            this.pushNotificationSocket.connect(); // Assuming connect() is the method to re-establish connection
                        }
                        else {
                            // If pushNotificationSocket is already connected
                            console.log('RestAPI::PushStream::NotifSocket::Status - Push notification socket already connected');
                        }
                    }
                    const shouldEmit = (eventType) => {
                        if (!this.listen || this.listen.length === 0) {
                            return true;
                        }
                        return this.listen.includes(eventType);
                    };
                    if (this.pushChatSocket) {
                        checkAndEmitConnectEvent();
                        this.pushChatSocket.off(pushStreamTypes_1.EVENTS.CONNECT);
                        this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            isChatSocketConnected = true;
                            this.chatSocketCount++;
                            this.chatSocketConnected = true;
                            checkAndEmitConnectEvent();
                            console.log(`RestAPI::PushStream::EVENTS.CONNECT:: Chat Socket Connected (ID: ${this.pushChatSocket.id})`);
                        }));
                        this.pushChatSocket.off(pushStreamTypes_1.EVENTS.DISCONNECT);
                        this.pushChatSocket.on(pushStreamTypes_1.EVENTS.DISCONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            console.log('RestAPI::PushStream::ChatSocket::Disconnect - Chat socket disconnected.');
                            yield handleSocketDisconnection('chat');
                        }));
                        this.pushChatSocket.off(pushStreamTypes_1.EVENTS.CHAT_GROUPS);
                        this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CHAT_GROUPS, (data) => {
                            try {
                                const modifiedData = DataModifier_1.DataModifier.handleChatGroupEvent(data, this.raw);
                                modifiedData.event = DataModifier_1.DataModifier.convertToProposedName(modifiedData.event);
                                modifiedData.streamUid = this.uid;
                                DataModifier_1.DataModifier.handleToField(modifiedData);
                                if (this.shouldEmitChat(data.chatId)) {
                                    if (data.eventType === pushStreamTypes_1.GroupEventType.JoinGroup ||
                                        data.eventType === pushStreamTypes_1.GroupEventType.LeaveGroup ||
                                        data.eventType === pushStreamTypes_1.MessageEventType.Request ||
                                        data.eventType === pushStreamTypes_1.GroupEventType.Remove ||
                                        data.eventType === pushStreamTypes_1.GroupEventType.RoleChange) {
                                        if (shouldEmit(pushStreamTypes_1.STREAM.CHAT)) {
                                            this.emit(pushStreamTypes_1.STREAM.CHAT, modifiedData);
                                        }
                                    }
                                    else {
                                        if (shouldEmit(pushStreamTypes_1.STREAM.CHAT_OPS)) {
                                            this.emit(pushStreamTypes_1.STREAM.CHAT_OPS, modifiedData);
                                        }
                                    }
                                }
                            }
                            catch (error) {
                                console.error('Error handling CHAT_GROUPS event:', error, 'Data:', data);
                            }
                        });
                        this.pushChatSocket.off(pushStreamTypes_1.EVENTS.CHAT_RECEIVED_MESSAGE);
                        this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CHAT_RECEIVED_MESSAGE, (data) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            try {
                                if (data.messageCategory == 'Chat' ||
                                    data.messageCategory == 'Request') {
                                    // Dont call this if read only mode ?
                                    if (this.decryptedPgpPvtKey) {
                                        data = yield this.chatInstance.decrypt([data]);
                                        data = data[0];
                                    }
                                }
                                const modifiedData = DataModifier_1.DataModifier.handleChatEvent(data, this.raw);
                                modifiedData.event = DataModifier_1.DataModifier.convertToProposedName(modifiedData.event);
                                DataModifier_1.DataModifier.handleToField(modifiedData);
                                if (this.shouldEmitChat(data.chatId)) {
                                    if (shouldEmit(pushStreamTypes_1.STREAM.CHAT)) {
                                        this.emit(pushStreamTypes_1.STREAM.CHAT, modifiedData);
                                    }
                                }
                            }
                            catch (error) {
                                console.error('Error handling CHAT_RECEIVED_MESSAGE event:', error, 'Data:', data);
                            }
                        }));
                        this.pushChatSocket.off('SPACES');
                        this.pushChatSocket.on('SPACES', (data) => {
                            try {
                                const modifiedData = DataModifier_1.DataModifier.handleSpaceEvent(data, this.raw);
                                modifiedData.event = DataModifier_1.DataModifier.convertToProposedNameForSpace(modifiedData.event);
                                DataModifier_1.DataModifier.handleToField(modifiedData);
                                if (this.shouldEmitSpace(data.spaceId)) {
                                    if (data.eventType === pushStreamTypes_1.SpaceEventType.Join ||
                                        data.eventType === pushStreamTypes_1.SpaceEventType.Leave ||
                                        data.eventType === pushStreamTypes_1.MessageEventType.Request ||
                                        data.eventType === pushStreamTypes_1.SpaceEventType.Remove ||
                                        data.eventType === pushStreamTypes_1.SpaceEventType.Start ||
                                        data.eventType === pushStreamTypes_1.SpaceEventType.Stop) {
                                        if (shouldEmit(pushStreamTypes_1.STREAM.SPACE)) {
                                            this.emit(pushStreamTypes_1.STREAM.SPACE, modifiedData);
                                        }
                                    }
                                    else {
                                        if (shouldEmit(pushStreamTypes_1.STREAM.SPACE_OPS)) {
                                            this.emit(pushStreamTypes_1.STREAM.SPACE_OPS, modifiedData);
                                        }
                                    }
                                }
                            }
                            catch (error) {
                                console.error('Error handling SPACES event:', error, 'Data:', data);
                            }
                        });
                        this.pushChatSocket.off('SPACES_MESSAGES');
                        this.pushChatSocket.on('SPACES_MESSAGES', (data) => {
                            try {
                                const modifiedData = DataModifier_1.DataModifier.handleSpaceEvent(data, this.raw);
                                modifiedData.event = DataModifier_1.DataModifier.convertToProposedNameForSpace(modifiedData.event);
                                DataModifier_1.DataModifier.handleToField(modifiedData);
                                if (this.shouldEmitSpace(data.spaceId)) {
                                    if (shouldEmit(pushStreamTypes_1.STREAM.SPACE)) {
                                        this.emit(pushStreamTypes_1.STREAM.SPACE, modifiedData);
                                    }
                                }
                            }
                            catch (error) {
                                console.error('Error handling SPACES event:', error, 'Data:', data);
                            }
                        });
                    }
                    if (this.pushNotificationSocket) {
                        checkAndEmitConnectEvent();
                        this.pushNotificationSocket.off(pushStreamTypes_1.EVENTS.CONNECT);
                        this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.CONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            console.log(`RestAPI::PushStream::NotifSocket::Connect - Notification Socket Connected (ID: ${this.pushNotificationSocket.id})`);
                            isNotifSocketConnected = true;
                            this.notifSocketCount++;
                            this.notifSocketConnected = true;
                            checkAndEmitConnectEvent();
                        }));
                        this.pushNotificationSocket.off(pushStreamTypes_1.EVENTS.DISCONNECT);
                        this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.DISCONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            console.log('RestAPI::PushStream::NotifSocket::Disconnect - Notification socket disconnected.');
                            yield handleSocketDisconnection('notif');
                        }));
                        this.pushNotificationSocket.off(pushStreamTypes_1.EVENTS.USER_FEEDS);
                        this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.USER_FEEDS, (data) => {
                            var _a;
                            try {
                                if (((_a = data.payload.data.additionalMeta) === null || _a === void 0 ? void 0 : _a.type) ===
                                    `${payloads_1.ADDITIONAL_META_TYPE.PUSH_VIDEO}+1` &&
                                    shouldEmit(pushStreamTypes_1.STREAM.VIDEO) &&
                                    this.shouldEmitVideo(data.sender)) {
                                    // Video Notification
                                    const modifiedData = DataModifier_1.DataModifier.mapToVideoEvent(data, this.account === data.sender
                                        ? pushStreamTypes_1.MessageOrigin.Self
                                        : pushStreamTypes_1.MessageOrigin.Other, this.raw);
                                    this.emit(pushStreamTypes_1.STREAM.VIDEO, modifiedData);
                                }
                                else {
                                    // Channel Notification
                                    const modifiedData = DataModifier_1.DataModifier.mapToNotificationEvent(data, pushStreamTypes_1.NotificationEventType.INBOX, this.account === data.sender ? 'self' : 'other', this.raw);
                                    if (this.shouldEmitChannel(modifiedData.from)) {
                                        if (shouldEmit(pushStreamTypes_1.STREAM.NOTIF)) {
                                            this.emit(pushStreamTypes_1.STREAM.NOTIF, modifiedData);
                                        }
                                    }
                                }
                            }
                            catch (error) {
                                console.error(`RestAPI::PushStream::NotifSocket::UserFeeds::Error - Error handling event: ${error}, Data: ${JSON.stringify(data)}`);
                            }
                        });
                        this.pushNotificationSocket.off(pushStreamTypes_1.EVENTS.USER_SPAM_FEEDS);
                        this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.USER_SPAM_FEEDS, (data) => {
                            try {
                                const modifiedData = DataModifier_1.DataModifier.mapToNotificationEvent(data, pushStreamTypes_1.NotificationEventType.SPAM, this.account === data.sender ? 'self' : 'other', this.raw);
                                modifiedData.origin =
                                    this.account === modifiedData.from ? 'self' : 'other';
                                if (this.shouldEmitChannel(modifiedData.from)) {
                                    if (shouldEmit(pushStreamTypes_1.STREAM.NOTIF)) {
                                        this.emit(pushStreamTypes_1.STREAM.NOTIF, modifiedData);
                                    }
                                }
                            }
                            catch (error) {
                                console.error('Error handling USER_SPAM_FEEDS event:', error, 'Data:', data);
                            }
                        });
                    }
                    this.disconnected = false;
                }))();
            });
        });
    }
    connected() {
        // Log the connection status of both sockets with detailed prefix
        console.log(`RestAPI::PushStream::connected::Notification Socket Connected: ${this.notifSocketConnected}`);
        console.log(`RestAPI::PushStream::connected::Chat Socket Connected: ${this.chatSocketConnected}`);
        return this.notifSocketConnected || this.chatSocketConnected;
    }
    disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Disconnect push chat socket if connected
            if (this.pushChatSocket && this.chatSocketConnected) {
                this.pushChatSocket.disconnect();
                console.log('RestAPI::PushStream::disconnect::Push chat socket disconnected.');
            }
            // Disconnect push notification socket if connected
            if (this.pushNotificationSocket && this.notifSocketConnected) {
                this.pushNotificationSocket.disconnect();
                console.log('RestAPI::PushStream::disconnect::Push notification socket disconnected.');
            }
        });
    }
    info() {
        return {
            options: this.options,
            listen: this.listen,
        };
    }
    shouldEmitChat(dataChatId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.chats) ||
            this.options.filter.chats.length === 0 ||
            this.options.filter.chats.includes('*')) {
            return true;
        }
        return this.options.filter.chats.includes(dataChatId);
    }
    shouldEmitSpace(dataSpaceId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.spaces) ||
            this.options.filter.spaces.length === 0 ||
            this.options.filter.spaces.includes('*')) {
            return true;
        }
        return this.options.filter.spaces.includes(dataSpaceId);
    }
    shouldEmitChannel(dataChannelId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.channels) ||
            this.options.filter.channels.length === 0 ||
            this.options.filter.channels.includes('*')) {
            return true;
        }
        return this.options.filter.channels.includes(dataChannelId);
    }
    shouldEmitVideo(dataVideoId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.video) ||
            this.options.filter.video.length === 0 ||
            this.options.filter.video.includes('*')) {
            return true;
        }
        return this.options.filter.video.includes(dataVideoId);
    }
}
exports.PushStream = PushStream;
//# sourceMappingURL=PushStream.js.map